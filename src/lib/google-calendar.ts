
import { CalendarEvent } from './calendar'

// You must replace this with your actual Google Cloud Project Client ID
// Enable "Google Calendar API" in your Google Cloud Console
// Add "http://localhost:3000" to "Authorized JavaScript origins"
const CLIENT_ID = process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID || 'YOUR_CLIENT_ID_HERE'
const API_KEY = process.env.NEXT_PUBLIC_GOOGLE_API_KEY || '' // Optional if using OAuth 2.0 closely, but usually needed for loading gapi client
const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest'
const SCOPES = 'https://www.googleapis.com/auth/calendar.events'

let tokenClient: any;
let gapiInited = false;
let gisInited = false;

export const loadGoogleScripts = (callback: () => void) => {
    if (typeof window === 'undefined') return;

    // Load GAPI
    const script1 = document.createElement('script');
    script1.src = 'https://apis.google.com/js/api.js';
    script1.async = true;
    script1.defer = true;
    script1.onload = () => {
        window.gapi.load('client', async () => {
            await window.gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: [DISCOVERY_DOC],
            });
            gapiInited = true;
            if (gisInited) callback();
        });
    };
    document.body.appendChild(script1);

    // Load GIS
    const script2 = document.createElement('script');
    script2.src = 'https://accounts.google.com/gsi/client';
    script2.async = true;
    script2.defer = true;
    script2.onload = () => {
        tokenClient = window.google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID,
            scope: SCOPES,
            callback: '', // defined later
        });
        gisInited = true;
        if (gapiInited) callback();
    };
    document.body.appendChild(script2);
}

export const syncEventsToGoogleCalendar = async (events: CalendarEvent[]): Promise<number> => {
    return new Promise((resolve, reject) => {
        // Ensure scripts are loaded
        if (!gapiInited || !gisInited) {
            loadGoogleScripts(() => {
                executeSync(events, resolve, reject)
            })
        } else {
            executeSync(events, resolve, reject)
        }
    });
}

const executeSync = (events: CalendarEvent[], resolve: (count: number) => void, reject: (err: any) => void) => {
    tokenClient.callback = async (resp: any) => {
        if (resp.error) {
            reject(resp);
            return;
        }
        try {
            const count = await createCalendarEvents(events);
            resolve(count);
        } catch (e) {
            reject(e);
        }
    };

    if (window.gapi.client.getToken() === null) {
        // Prompt the user to select a Google Account and ask for consent to share their data
        // when establishing a new session.
        tokenClient.requestAccessToken({ prompt: 'consent' });
    } else {
        // Skip display of account chooser and consent dialog for an existing session.
        tokenClient.requestAccessToken({ prompt: '' });
    }
}

const createCalendarEvents = async (events: CalendarEvent[]): Promise<number> => {
    const batch = window.gapi.client.newBatch();

    // We can create a dedicated calendar or use 'primary'

    // Limit to prevent rate limiting, maybe 50?
    // For now, let's just loop a few

    let createdCount = 0;

    for (const event of events) {
        // Basic check to avoid duplicates (very naive, assumes title match on same day)
        // In reality, we should query existing events using timeMin/timeMax

        // Define event resource
        // Date-only events for birthdays/anniversaries
        const resource = {
            'summary': event.title,
            'description': event.description + `\n\nGenerated by Gia Pha Viet`,
            'start': {
                'date': event.date.toISOString().split('T')[0] // YYYY-MM-DD
            },
            'end': {
                'date': event.date.toISOString().split('T')[0] // single day event (end is same day or next day?)
                // Google Calendar API: for all-day events, 'end.date' is exclusive. So needs to be next day.
            },
            'transparency': 'transparent', // Available
            'reminders': {
                'useDefault': false,
                'overrides': [
                    { 'method': 'popup', 'minutes': 9 * 60 }, // 9 AM on the day
                    { 'method': 'email', 'minutes': 24 * 60 }, // 1 day before
                ],
            },
        };

        // Fix End Date (add 1 day)
        const endDate = new Date(event.date);
        endDate.setDate(endDate.getDate() + 1);
        resource.end.date = endDate.toISOString().split('T')[0];

        const listRequest = await window.gapi.client.calendar.events.list({
            'calendarId': 'primary',
            'timeMin': new Date(event.date.setHours(0, 0, 0, 0)).toISOString(),
            'timeMax': new Date(event.date.setHours(23, 59, 59, 999)).toISOString(),
            'singleEvents': true,
        });

        const existing = listRequest.result.items.find((e: any) => e.summary === event.title);

        if (!existing) {
            await window.gapi.client.calendar.events.insert({
                'calendarId': 'primary',
                'resource': resource,
            });
            createdCount++;
        }
    }

    return createdCount;
}

// Type definitions for window
declare global {
    interface Window {
        gapi: any;
        google: any;
    }
}
